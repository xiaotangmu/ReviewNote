二叉树作为树的一种，是一种重要的数据结构，二叉树中的面试题比较常见的题型大概有下面几个：创建一颗二叉树（先序，中序，后序）、遍历一颗二叉树（先序，中序，后序和层次遍历）、求二叉树中叶子节点的个数、求二叉树的高度、求二叉树中两个节点的最近公共祖先、打印和为某一值的全部路径、求某一节点是否在一个树中等等。

几种常见的二叉树：

完全二叉树：若二叉树的高度是h，除第h层之外，其他（1~h-1）层的节点数都达到了最大个数，并且第h层的节点都连续的集中在最左边。想到点什么没？实际上，完全二叉树和堆联系比较紧密哈~~~

满二叉树：除最后一层外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点。

哈夫曼树：又称为最优数，这是一种带权路径长度最短的树。哈夫曼编码就是哈夫曼树的应用。

平衡二叉树：所谓平衡二叉树指的是，左右两个子树的高度差的绝对值不超过 1。

红黑树：红黑树是每个节点都带颜色的树，节点颜色或是红色或是黑色，红黑树是一种查找树。红黑树有一个重要的性质，从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍。对于红黑树，插入，删除，查找的复杂度都是O（log N）。

原文链接：https://blog.csdn.net/heyuchang666/article/details/49364235


遍历
层次遍历
层次遍历也是二叉树遍历的一种方式，二叉树的层次遍历更像是一种广度优先搜索（BFS）。

先序遍历 -- （根先） 中 - 左 - 右
中序遍历 -- （根中） 左 - 中 - 右
后序遍历 -- （根后） 左 - 右 - 中

深度优先搜索（dfs）-- 不到墙头心不死 
　　　　1、首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；

　　　　2、当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。

广度优先搜索（bfs）-- 层次搜索
从A开始，有4个邻接点，“B，C，D，F”，这是第二层；

在分别从B，C，D，F开始找他们的邻接点，为第三层。以此类推。

二叉树是树的特殊一种，具有如下特点：

1、每个结点最多有两颗子树，结点的度最大为2。
2、左子树和右子树是有顺序的，次序不能颠倒。
3、即使某结点只有一个子树，也要区分左右子树。

二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。

原文链接：https://blog.csdn.net/yeyazhishang/article/details/82353846

基本术语
结点：存储数据元素和指向子树的链接，由数据元素和构造数据元素之间关系的引用组成。
孩子结点：树中一个结点的子树的根结点称为这个结点的孩子结点，如图1中的A的孩子结点有B、C、D
双亲结点：树中某个结点有孩子结点(即该结点的度不为0)，该结点称为它孩子结点的双亲结点，也叫前驱结点。双亲结点和孩子结点是相互的，如图1中，A的孩子结点是B、C、D，B、C、D的双亲结点是A。
兄弟结点：具有相同双亲结点(即同一个前驱)的结点称为兄弟结点，如图1中B、B、D为兄弟结点。
结点的度：结点所有子树的个数称为该结点的度，如图1，A的度为3，B的度为2.
树的度：树中所有结点的度的最大值称为树的度，如图1的度为3.
叶子结点：度为0的结点称为叶子结点，也叫终端结点。如图1的K、L、F、G、M、I、J
分支结点：度不为0的结点称为分支结点，也叫非终端结点。如图1的A、B、C、D、E、H
结点的层次：从根结点到树中某结点所经路径的分支数称为该结点的层次。根结点的层次一般为1(也可以自己定义为0)，这样，其它结点的层次是其双亲结点的层次加1.
树的深度：树中所有结点的层次的最大值称为该树的深度(也就是最下面那个结点的层次)。
有序树和无序树：树中任意一个结点的各子树按从左到右是有序的，称为有序树，否则称为无序树。
树的抽象数据类型描述
数据元素：具有相同特性的数据元素的集合。
结构关系：树中数据元素间的结构关系由树的定义确定。


 哈夫曼树相关的几个名词
路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

    WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3


 构造方法：

首先统计出每种字符出现的频率！（也可以是概率）//权值

------------------------------------------------------------------------------------------------

           例如：频率表 A：60,    B:45,   C:13   D:69   E:14   F:5  G:3

第一步：找出字符中最小的两个，小的在左边，大的在右边，组成二叉树。在频率表中删除此次找到的两个数，并加入此次最小两个数的频率和。

F和G最小，因此如图，从字符串频率计数中删除F与G，并返回G与F的和 8给频率表

 重复第一步：

-------------------------------------------------------------------------------------------------

频率表 A：60,    B:45,   C:13   D:69   E:14   FG:8

最小的是 FG：8与C：13，因此如图，并返回FGC的和：21给频率表。

---------------------------------------------------------------------------------------------------

重复第一步：

---------------------------------------------------------------------------------------------------

频率表 A：60    B: 45   D: 69   E: 14   FGC: 21

如图

-----------------------------------------------------------------------------------------------------

重复第一步

-----------------------------------------------------------------------------------------------------

频率表 A：60    B: 45   D: 69  FGCE: 35

-----------------------------------------------------------------------------------------------------

重复第一步

-----------------------------------------------------------------------------------------------------

频率表 A：60   D: 69  FGCEB: 80

-----------------------------------------------------------------------------------------------------

重复第一步

-----------------------------------------------------------------------------------------------------

频率表 AD：129  FGCEB: 80

添加 0 和 1，规则左0 右1

 

频率表 A：60,    B:45,   C:13   D:69   E:14   F:5  G:3

每个 字符 的 二进制编码 为（从根节点 数到对应的叶子节点，路径上的值拼接起来就是叶子节点字母的应该的编码）
字符 	编码
A 	10
B 	01
C 	0011
D 	11
E 	000
F 	00101
G 	00100

 

 

 

 

 

 

 

 

 

那么当我想传送 ABC时，编码为 10 01 0011

思考：

大家观察 出现得越多的字母，他的编码越短 ，出现频率越少的字母，他的编码越长。

在信息传输过程中，如果这个字母越多，那么我们希望他越瘦小（编码短）这样占用的编码越少，其实编码长的字母也是让频率比它多的字母把编码短的位子都占用后，他才去占用当前最短的编码。至此让总的编码长度最短。

且要保证长编码的不与短编码的字母冲突：

比如 不能出现 读码 读到 01  还有长编码的 字母为011，如果短编码为一个长编码的左起子串，这就是冲突，意思就是说读到当前位置已经能确定是什么字母时不能因为再读取一位或几位让这个编码能表示另外的字母，

但哈夫曼树（最优二叉树）在构造的时候就避免了这个问题。为什么能避免呢，因为哈夫曼树的它的字母都在叶子节点上，因此不会出现一个字母的编码为另一个字母编码左起子串的情况。

 

提问：
1.为什么要保证长编码不与短编码冲突？

冲突情况：如果我们已经确定D，E，F，G 用 01 ，010 ，10，001的2进制编码来传输了。那么想传送FED时，我需要传送     1001001，接收方可以把它解析为FDG（10 01 001），当然也能解析为FED（10 010 01），他两编码一样的，这就是编码冲突，（这里编码冲突的原因，也是因为编码时，D的编码是E的编码的左起子串了）显然这是不行的，就像我说压脉带，你如果是日本人会理解为 （你懂得），这就是发出同一种语，得出不同的意的情况。所以不能让一个字母的二进制代表数，为另一个字母的二进制代表数的子串。但为什么实际情况只要求编码时，一个编码不是另一编码的左起子串呢而不是绝对意义上的非子串呢，因为计算机从数字串的左边开始读，如果从右边读，那么可以要求是非右起（无奈）。你又可以问了为什么编码要求是非左起或非右起不直接规定不能是子串呢（也行，不过=>），比如说原文中B就是C，F，G的子串，那这不就不符合规则了么。这里是为了哈夫曼的根本目的，优化编码位占用问题，如果完全不能有任何子串那么编码将会非常庞大。但这里计算机是一位一位的·读取编码的，只需要保证计算机在读取中不会误判就行。并且编码占用最少。

code：0110101001110

左起子串：011

右起子串：110

绝对非子串：1110111  此串在code中完全找不到
2.那么哈夫曼树怎么避免左起子串问题呢？

因为哈夫曼是从叶子节点开始构造，构造到根节点的，而且构造时，都是计算两个权值的节点的和再与其他叶子节点再生成一个父节点来组成一个新的树。并且不允许任何带有权值的节点作为他们的父节点。这也保证了所有带有权值的节点都被构造为了叶子节点。然后最后编码的时候是从根节点开始走到叶子节点而得出的编码。在有权值的节点又不会出现在任何一条路的路途中的情况，只会出现在终点的情况下，因此不会出现01代表一个字母011又代表一个字母。

又如原文ABC编码为10010011的情况，当计算机读到10时，由于有左起子串不冲突的原则。那么计算机完全可以保证当前的10就是A字母，然后再往下读010011的部分，然后当读到01时，也完全能确定B，C同理，而不用说因为会出现冲突的编码而接着继续读取之后的编码来确定前面的编码。这样对信息的判断和效率是相当的不利的，也不是说不可以。即使你ABCD,分别用01,011,0111,01111来代替也行，传输后也能精确识别，但是数据量极大呢，想代替整个中文编码呢，那0后面得多少个1才能代表完。因此哈夫曼就是为了获得最少编码量代替最多字符串，并且不冲突，系统不会误判而产生的。
3.这里要提一下同权不同构

已经有朋友问起这个问题了。这里要说一下哈夫曼树的构造并不是唯一的。

考虑如下情况：

有权值分别为 5,29,7,8,14,23,3,11的情况，可以如下图一样构造。

带权路径长度：

(5+3+7+8)*4+

(11+14)*3+

(23+29)*2

=271

也可以如下图构造：

带权路径长度：

（3+5)*5+

7*4+

(8+11+14)*3+

(23+29)*2

=271

这两种不同的方式构造出来的哈夫曼树，得出的带权路径长度相等，那么选哪颗树都可以，这就叫同权不同构。
————————————————
版权声明：本文为CSDN博主「Anakki」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_29519041/article/details/81428934
