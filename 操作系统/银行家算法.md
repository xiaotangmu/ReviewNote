原文链接：https://blog.csdn.net/qq_33414271/article/details/80245715



一句话：

当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

    那么此时会有一个问题，如何判断系统是否处于安全状态？算法流程将用下面一张图来表示。

一张图

这里写图片描述

![这里写图片描述](https://img-blog.csdn.net/20180508204335770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDE0Mjcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

    首先是银行家算法中的进程：
    包含进程Pi的需求资源数量（也是最大需求资源数量，MAX）
    已分配给该进程的资源A（Allocation）
    还需要的资源数量N（Need=M-A）
    
    Available为空闲资源数量，即资源池（注意：资源池的剩余资源数量+已分配给所有进程的资源数量=系统中的资源总量）

假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。

若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–>回收（Work+已分配给P0的A0=Work）–>分配给P3–>回收（Work+A3=Work）–>分配给P2–>······满足所有进程）。

如此就可避免系统存在潜在死锁的风险。



来个例子  -- 序列按顺序执行

在银行家算法中，若出现下述资源分配情况：
这里写图片描述

    注：题中共四种资源，P0的Allocation为（0，0，3，2）表示已分配给P0的第一种资源和第二种资源为0个，第三种资源3个，第四种资源2个。

（1）该状态是否安全？ （2）若进程P2提出请求Request（1，2，2，2）后，系统能否将资源分配给它？

（1）利用安全性算法对上面的状态进行分析（见下表），找到了一个安全序列{P0,P3,P4,P1,P2}，故系统是安全的。
这里写图片描述

（2）P2发出请求向量Request(1,2,2,2),系统按银行家算法进行检查：

①Request2(1,2,2,2)<=Need2(2,3,5,6)
②Request2(1,2,2,2)<=Available(1,6,2,2)
③系统先假定可为P2分配资源，并修改Available，Allocation2和Need2向量：
Available=(0,4,0,0)
Allocation2=(2,5,7,6)
Need2=(1,1,3,4)
此时再进行安全性检查，发现 Available=(0,4,0,0) 不能满足任何一个进程，所以判定系统进入不安全状态，即不能分配给P2相应的Request(1,2,2,2)。
————————————————




原文链接：https://blog.csdn.net/qq_34669785/article/details/78699082



银行家算法的详细描述，请自行查阅资料。

笔者只以一道简单的题目做描述。

题目：

5个进程从p0到p4

3个资源类型A(10个实例),B（5个实例）,C（7个实例）

具体输入如下表:

在T0时刻有：


​	

Allocation
​	

Max
​	

Available


​	

A  B  C
​	

A  B   C
​	

A  B   C

P0
​	

0   1  0
​	

7  5    3
​	

3  3    2

P1
​	

2   0  0
​	

3  2    2

P2
​	

3   0  2
​	

9  0    2

P3
​	

2   1  1
​	

2   2   2

P4
​	

0   0  2
​	

4   3   3

Available表示每类资源可用的数量。
Allocation表示当前分给每个进程的资源数目。

Max表示每个进程对资源的最大需求


答案分析如下表：

  初始时：

   Work：= Available 

   Need：=Max-Allocation

即：（只看黑字）


​	

Work
​	

Need
​	

Allcation
​	

Work=Work+Allcation
​	

finish（Work+Allcation<(10,5,7)）


​	

A   B  C
​	

A   B  C
​	

A   B  C
​	

A   B  C
​	

 

P0
​	


​	

7   4   5
	0    1   1 	  	


P1
​	

 3 3   2
​	

1  2   2
	2  0   0 	5   3   2 	

true

P2
​	


	6  0   0 	3   0   2 	  	


P3
​	

5   3   2
​	

0  1   1
	2  1   1 	

7   4    3
​	

true

P4
​	


​	

4   3   1
​	

0   0  2
​	


​	


开始时Work=Available=(3,3,2)我们可以看到Need P1 P3 资源可以满足 Work>=Need，从算法遍历运行的顺序可知，先P1行求得（红字），work=(5,3,2)

然后看P2不满足Work>=Need，P3满足条件Work>=Need，P1行求得（蓝色）。以此类推，P4也可以求出。之后又从头开始遍历，依次完成P0，P2。

当完成后，finish都为true表示，系统处于安全状态。输出顺序就可以了，如下图：



​	

Work
​	

Need
​	

Allcation
​	

Work+Allcation
​	

finish


​	

A   B  C
​	

A   B  C
​	

A   B  C
​	

A   B  C
​	

 

P1
​	

3   3   2
​	

1   2   2
​	

2   0   0
​	

5    3   2
​	

true

P3
​	

5   3   2
​	

0   1   1
​	

2   1   1
​	

7   4    3
​	

true

P4
​	

7   4   3
​	

4   3   1
​	

0   0   2
​	

7    4   5
​	

true

P0
​	

7   4   5
​	

7   4   3
​	

0   1   0
​	

7    5   5
​	

true

P2
​	

7   5   5
​	

6   0   0
​	

3   0   2
​	

10    5    7
​	

true

如表银行家算法的结果为 <P1,P3,P4,P0,P2>
————————————————

