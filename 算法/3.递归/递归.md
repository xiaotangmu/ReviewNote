 https://blog.csdn.net/weixin_43025071/article/details/89149695

**递归**：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。

**循环**：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。

　　 上面的比喻形象地阐述了递归与循环的内涵，那么我们来思考以下几个问题：

什么是递归呢？ 
递归的精髓(思想)是什么？ 
递归和循环的区别是什么？ 
什么时候该用递归？ 
使用递归需要注意哪些问题？ 
递归思想解决了哪些经典的问题？ 
这些问题正是笔者准备在本文中详细阐述的问题。

二. 递归的内涵

1、定义 (什么是递归？)

　　 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。

2、递归思想的内涵(递归的精髓是什么？)

　　 正如上面所描述的场景，递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。

![img](https://img-blog.csdn.net/20170615220708910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzgwNTI5OTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

更直接地说，递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。

3、用归纳法来理解递归

　　 数学都不差的我们，第一反应就是递归在数学上的模型是什么，毕竟我们对于问题进行数学建模比起代码建模拿手多了。观察递归，我们会发现，递归的数学模型其实就是 数学归纳法，这个在高中的数列里面是最常用的了，下面回忆一下数学归纳法。

**而递归和我们的思维方式正好相反。**

那我们怎么判断这个递归计算是否是正确的呢？Paul Graham 提到一种方法，如下：

> 如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。
>
> 1. 当 n=0,1 时，结果正确；
> 2. 假设递归对于 n 是正确的，同时对于 n+1 也正确。

这种方法很像数学归纳法，也是递归正确的思考方式，上述的第 1 点称为基本情况，第 2 点称为通用情况。

在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。

　　 数学归纳法适用于将解决的原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：

步进表达式：问题蜕变成子问题的表达式 
结束条件：什么时候可以不再使用步进表达式 
直接求解表达式：在结束条件下能够直接计算返回值的表达式 
事实上，这也正是某些数学中的数列问题在利用编程的方式去解决时可以使用递归的原因，比如著名的斐波那契数列问题。

4、递归的三要素

　　 在我们了解了递归的基本思想及其数学模型之后，我们如何才能写出一个漂亮的递归程序呢？笔者认为主要是把握好如下三个方面：

1、明确递归终止条件； 

2、给出递归终止时的处理办法； 

3、提取重复的逻辑，缩小问题规模。

 

**1). 明确递归终止条件**

　　 我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。

**2). 给出递归终止时的处理办法**

　　 我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。

**3). 提取重复的逻辑，缩小问题规模\***

　　 我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。

5、递归算法的编程模型

　　 在我们明确递归算法设计三要素后，接下来就需要着手开始编写具体的算法了。在编写算法时，不失一般性，我们给出两种典型的递归算法设计模型，如下所示。

**模型一： 在递去的过程中解决问题** 

```
function recursion(大规模){

    if (end_condition){      // 明确的递归终止条件

        end;   // 简单情景

    }else{            // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题
        solve;                // 递去

        recursion(小规模);     // 递到最深处后，不断地归来

    }

}
```

**模型二： 在归来的过程中解决问题**

```
function recursion(大规模){

    if (end_condition){      // 明确的递归终止条


        end;   // 简单情景

    }else{            // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题

        recursion(小规模);     // 递去

        solve;                // 归来
    }
}
```

6、递归的应用场景

　　 在我们实际学习工作中，递归算法一般用于解决三类问题：

　　 (1). 问题的定义是按递归定义的（Fibonacci函数，阶乘，…）；

　　 (2). 问题的解法是递归的（有些问题只能使用递归方法来解决，例如，汉诺塔问题，…）；

　　 (3). 数据结构是递归的（链表、树等的操作，包括树的遍历，树的深度，…）。

　　在下文我们将给出递归算法的一些经典应用案例，这些案例基本都属于第三种类型问题的范畴。

三. 递归与循环

　　 递归与循环是两种不同的解决问题的典型思路。递归通常很直白地描述了一个问题的求解过程，因此也是最容易被想到解决方式。循环其实和递归具有相同的特性，即做重复任务，但有时使用循环的算法并不会那么清晰地描述解决问题步骤。单从算法设计上看，递归和循环并无优劣之别。然而，在实际开发中，因为函数调用的开销，递归常常会带来性能问题，特别是在求解规模不确定的情况下；而循环因为没有函数调用开销，所以效率会比递归高。递归求解方式和循环求解方式往往可以互换，也就是说，如果用到递归的地方可以很方便使用循环替换，而不影响程序的阅读，那么替换成循环往往是好的。问题的递归实现转换成非递归实现一般需要两步工作：

　　 (1). 自己建立“堆栈(一些局部变量)”来保存这些内容以便代替系统栈，比如树的三种非递归遍历方式；

　　 (2). 把对递归的调用转变为对循环处理。

　　 特别地，在下文中我们将给出递归算法的一些经典应用案例，对于这些案例的实现，我们一般会给出递归和非递归两种解决方案，以便读者体会。

四. 经典递归问题实战

1. 第一类问题：问题的定义是按递归定义的 
2. (1). 阶乘

​     

```
/**
 * Title: 阶乘的实现 
 * Description:
 *      递归解法
 *      非递归解法
 * @author rico
 */
public class Factorial {
    /**     
     * @description 阶乘的递归实现
     * @author rico       
     * @created 2017年5月10日 下午8:45:48     
     * @param n
     * @return     
     */
    public static long f(int n){
        if(n == 1)   // 递归终止条件 
            return 1;    // 简单情景
        return n*f(n-1);  // 相同重复逻辑，缩小问题的规模
    }


--------------------------------我是分割线-------------------------------------

    /**     
     * @description 阶乘的非递归实现
     * @author rico       
     * @created 2017年5月10日 下午8:46:43     
     * @param n
     * @return     
     */
    public static long f_loop(int n) {
        long result = n;

        while (n > 1) {
            n--;
            result = result * n;
        }
        return result;
    }
}
```

(2). 斐波纳契数列

```
/** 
* Title: 斐波纳契数列 
* 
* Description: 斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… 
* 在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n>=2，n∈N*）。 
* 
* 两种递归解法：经典解法和优化解法 
* 两种非递归解法：递推法和数组法  
* @author rico
 */

public class FibonacciSequence {
    /**
     * @description 经典递归法求解
     * 
     * 斐波那契数列如下：
     * 
     *  1,1,2,3,5,8,13,21,34,...
     * 
     * *那么，计算fib(5)时，需要计算1次fib(4),2次fib(3),3次fib(2)，调用了2次fib(1)*，即：
     * 
     *  fib(5) = fib(4) + fib(3)
     *  
     *  fib(4) = fib(3) + fib(2) ；fib(3) = fib(2) + fib(1)
     *  
     *  fib(3) = fib(2) + fib(1)
     * 
     * 这里面包含了许多重复计算，而实际上我们只需计算fib(4)、fib(3)、fib(2)和fib(1)各一次即可，
     * 后面的optimizeFibonacci函数进行了优化，使时间复杂度降到了O(n).
     * 
     * @author rico
     * @created 2017年5月10日 下午12:00:42
     * @param n
     * @return
     */
    public static int fibonacci(int n) {
        if (n == 1 || n == 2) {     // 递归终止条件
            return 1;       // 简单情景
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // 相同重复逻辑，缩小问题的规模
    }
```

(3). 杨辉三角的取值

```
    /**     
     * @description 递归获取杨辉三角指定行、列(从0开始)的值
     *              注意：与是否创建杨辉三角无关    
     * @author rico 
     * @x  指定行
     * @y  指定列    
     */



  /**
    * Title: 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。
    * 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。
    * 
    * 例如，下面给出了杨辉三角形的前4行： 
    *    1 
    *   1 1
    *  1 2 1
    * 1 3 3 1
    * @description 递归获取杨辉三角指定行、列(从0开始)的值
    *              注意：与是否创建杨辉三角无关
    * @author rico 
    * @x  指定行
    * @y  指定列  
    */
    public static int getValue(int x, int y) {

        if(y <= x && y >= 0){

            if(y == 0 || x == y){   // 递归终止条件

                return 1; 

            }else{ 
                // 递归调用，缩小问题的规模
                return getValue(x-1, y-1) + getValue(x-1, y); 

            }
            
        }
        return -1;
    } 
}
```

​         (1). 汉诺塔问题

1. 第二类问题：问题解法按递归算法实现

​    

```
/** 
* Title: 汉诺塔问题 
* Description:古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。 
* 有一个和尚想把这64个盘子从A座移到C座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下， 
* 小盘在上。在移动过程中可以利用B座。要求输入层数，运算后输出每步是如何移动的。 
*
* @author rico
 */
public class HanoiTower {

    /**     
     * @description 在程序中，我们把最上面的盘子称为第一个盘子，把最下面的盘子称为第N个盘子
     * @author rico       
     * @param level：盘子的个数
     * @param from 盘子的初始地址
     * @param inter 转移盘子时用于中转
     * @param to 盘子的目的地址
     */



    public static void moveDish(int level, char from, char inter, char to) {
        if (level == 1) { // 递归终止条件
            System.out.println("从" + from + " 移动盘子" + level + " 号到" + to);

        } else {

            // 递归调用：将level-1个盘子从from移到inter(不是一次性移动，每次只能移动一个盘子,其中to用于周转)
            moveDish(level - 1, from, to, inter); // 递归调用，缩小问题的规模
            // 将第level个盘子从A座移到C座
            System.out.println("从" + from + " 移动盘子" + level + " 号到" + to); 
            // 递归调用：将level-1个盘子从inter移到to,from 用于周转
            moveDish(level - 1, inter, from, to); // 递归调用，缩小问题的规模
        }

    }
    public static void main(String[] args) {
        int nDisks = 30;
        moveDish(nDisks, 'A', 'B', 'C')

    }
```

1. 第三类问题：数据的结构是按递归定义的

​       (1). 二叉树深度 

 

```
/** 
* Title: 递归求解二叉树的深度 
* Description: 
* @author rico 
* @created 2017年5月8日 下午6:34:50 
*/
public class BinaryTreeDepth {
    /**     
     * @description 返回二叉数的深度
     * @author rico       
     * @param t
     * @return     
     */
    public static int getTreeDepth(Tree t) {
        // 树为空

        if (t == null) // 递归终止条件

            return 0;

        int left = getTreeDepth(t.left); // 递归求左子树深度，缩小问题的规模

        int right = getTreeDepth(t.left); // 递归求右子树深度，缩小问题的规模

        return left > right ? left + 1 : right + 1;

    }

}
```





遍历二叉树，是学习树这种数据结构首先要理解的一种基本操作。比较简单地方式就是用递归去遍历，鉴于递归这种调用方法有一定的特殊性，今天还是想来讲讲怎么去理解递归遍历。本文针对想理解递归的过程的朋友，因为本人在学到这一部分的时候也纠结了很久，其实只要理解了过程，那以后写递归的代码再也不用“心虚”了，因为那个过程是可预测的，可证明的。

递归调用的特殊性在于自己调用自己，给人一种迷茫感，如果是递归调用“一次”，那还相对好理解，比如求阶乘的递归算法，

    int F(int n)
    {
    	if(n==0)//递归边界
                return 1;
    	return n*F(n-1);//递归公式
    }

一层一层调用，知道递归结束条件成立，再一层一层返回；但如果像二叉树是递归调用“两次”，似乎理解起来就不是很容易了。

    void preorder(bintree t){
        if(t){
            printf("%c ",t->data);
            preorder(t->lchild);
            preorder(t->rchild);
        }
    }

对于一颗如下的二叉树，它的前序遍历顺序该怎么理解呢？我们今天来好好理一遍它的过程。

可以把递归看成是自己调用另一个和自己功能一样，但是函数名不同的函数来理解，或许看得更清楚明白，下面我们来看看这个前序遍历的过程是怎样的。

首先，我们记上面这个函数为F1，表示外层的函数，内层函数表示下一层的函数，也就是第二层的F2，依次类推。


那从F1依次调用直到F3，注意这个时候都是在左子树就是L的调用，所以依次打印出“A B D ”,这都没什么问题，就是普通函数调用。F3调用F4的时候，记得我们层函数的最前面是递归的退出条件，也就是空子树就返回，由于D的左子树是空，所以到这里F4会返回到F3，即返回到L之后，R之前。


接在，在F3层，从R开始继续调用F4，即开始访问D的右子树，此时打印出“F”，然后调用F4的左子树，也就是调用F5函数，当然是空，所以返回到F4,再调用F4的右子树，也是空，所以也是返回到F4，此时F4这一层已经全部调用完成，所以继续向上返回到F3，记得我们之前是怎么下来的吗，就是从F3的右子树开始访问，所以F3层函数也已经调用完成，继续往上返回到F2。


继续调用F2的右子树，也就是调用F3函数，此时打印出“E”，接着再访问E的左右子树，都是空，所以返回到F2，F2层函数已经全部调用完成。返回到F1，也就是A的左子树部分全部访问完成，此时开始访问A的右子树，打印出“C”，再推下去就是依次打印“G”和“H”。至此，整颗二叉树节点前序遍历完成，顺序就是“A B D F E C G H”。

二叉树是一种递归定义的数据结构，所以用递归来写它的相关算法是顺理成章的，只是有时候觉得需要稍微理解一下这个过程，这个就是我的理解方法。
————————————————
版权声明：本文为CSDN博主「allenchenhh133」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/allenchenhh133/article/details/80291252