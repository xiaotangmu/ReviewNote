next() 函数理解：当前字符要匹配模板字符的位置

计算：看当前字符的前一位字符串，找最长匹配字符串maxL，再由该maxL下一位字符与当前字符比较，即next()

的值就为该maxL的下位字符下标

如：abcab

若当前字符为第二个b，则找到前一位字符串maxL为a (值：maxL = 1)，看该maxL下位字符为b，下标1（从0开始），所以此时该b的next() = 1 -- b的位置（下标）

nextval(i) 函数理解 -- 看结果：用当前字符与next(i) （下标）对应的字符比较，不相等值=next(i), 相同时，nextval(i) = nextval(next(i)) -- 找下标字符的nextval(j)  -- 不同则同，同则等于



简单计算看最下：





原文：https://segmentfault.com/a/1190000008575379

## 一：背景

给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。

Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在 1974 年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于 1977 年联合发表。

在继续下面的内容之前，有必要在这里介绍下两个概念：**真前缀** 和 **真后缀**。

![img](https://segmentfault.com/img/remote/1460000021457885)

由上图所得， "真前缀"指除了自身以外，一个字符串的全部头部组合；"真后缀"指除了自身以外，一个字符串的全部尾部组合。（网上很多博客，应该说是几乎所有的博客，也包括我以前写的，都是“前缀”。严格来说，“真前缀”和“前缀”是不同的，既然不同，还是不要混为一谈的好！）

## 二：朴素字符串匹配算法

初遇串的模式匹配问题，我们脑海中的第一反应，就是朴素字符串匹配（即所谓的暴力匹配），代码如下：

```
/* 字符串下标始于 0 */
int NaiveStringSearch(string S, string P)
{
    int i = 0;    // S 的下标
    int j = 0;    // P 的下标
    int s_len = S.size();
    int p_len = P.size();

    while (i < s_len && j < p_len)
    {
        if (S[i] == P[j])  // 若相等，都前进一步
        {
            i++;
            j++;
        }
        else               // 不相等
        {
            i = i - j + 1;
            j = 0;
        }
    }

    if (j == p_len)        // 匹配成功
        return i - j;

    return -1;
}
```

暴力匹配的时间复杂度为 ，其中  为 S 的长度， 为 P 的长度。很明显，这样的时间复杂度很难满足我们的需求。

接下来进入正题：时间复杂度为  的 KMP 算法。

## 三：KMP字符串匹配算法

### 3.1 算法流程

以下摘自阮一峰的[字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)，并作稍微修改。

（1）

![img](https://segmentfault.com/img/remote/1460000021457884)

首先，主串"BBC ABCDAB ABCDABCDABDE"的第一个字符与模式串"ABCDABD"的第一个字符，进行比较。因为 B 与 A 不匹配，所以模式串后移一位。

（2）

![img](https://segmentfault.com/img/remote/1460000021457876)

因为 B 与 A 又不匹配，模式串再往后移。

（3）

![img](https://segmentfault.com/img/remote/1460000021457880)

就这样，直到主串有一个字符，与模式串的第一个字符相同为止。

（4）

![img](https://segmentfault.com/img/remote/1460000021457874)

接着比较主串和模式串的下一个字符，还是相同。

（5）

![img](https://segmentfault.com/img/remote/1460000021457883)

直到主串有一个字符，与模式串对应的字符不相同为止。

（6）

![img](https://segmentfault.com/img/remote/1460000021457882)

这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍。

（7）

![img](https://segmentfault.com/img/remote/1460000021457875)

一个基本事实是，当空格与 D 不匹配时，你其实是已经知道前面六个字符是"ABCDAB"。KMP 算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。

（8）

| i       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串     | A    | B    | C    | D    | A    | B    | D    | '\0' |
| next[i] | -1   | 0    | 0    | 0    | 0    | 1    | 2    | 0    |

怎么做到这一点呢？可以针对模式串，设置一个跳转数组`int next[]`，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。

（9）

![img](https://segmentfault.com/img/remote/1460000021457881)

已知空格与 D 不匹配时，前面六个字符"ABCDAB"是匹配的。根据跳转数组可知，不匹配处 D 的 next 值为 2，因此接下来**从模式串下标为 2 的位置开始匹配**。

（10）

![img](https://segmentfault.com/img/remote/1460000021457879)

因为空格与 Ｃ 不匹配，C 处的 next 值为 0，因此接下来模式串从下标为 0 处开始匹配。

（11）

![img](https://segmentfault.com/img/remote/1460000021457877)

因为空格与 A 不匹配，此处 next 值为 -1，表示模式串的第一个字符就不匹配，那么直接往后移一位。

（12）

![img](https://segmentfault.com/img/remote/1460000021457878)

逐位比较，直到发现 C 与 D 不匹配。于是，下一步从下标为 2 的地方开始匹配。

（13）

![img](https://segmentfault.com/img/remote/1460000021457887)

逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。

### 3.2 next 数组是如何求出的

next 数组的求解基于“真前缀”和“真后缀”，即`next[i]`等于`P[0]...P[i - 1]`最长的相同真前后缀的长度（请暂时忽视 i 等于 0 时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。

| i         | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串       | A    | B    | C    | D    | A    | B    | D    | '\0' |
| next[ i ] | -1   | 0    | 0    | 0    | 0    | 1    | 2    | 0    |

1. i = 0，对于模式串的首字符，我们统一为`next[0] = -1`；
2. i = 1，前面的字符串为`A`，其最长相同真前后缀长度为 0，即`next[1] = 0`；
3. i = 2，前面的字符串为`AB`，其最长相同真前后缀长度为 0，即`next[2] = 0`；
4. i = 3，前面的字符串为`ABC`，其最长相同真前后缀长度为 0，即`next[3] = 0`；
5. i = 4，前面的字符串为`ABCD`，其最长相同真前后缀长度为 0，即`next[4] = 0`；
6. i = 5，前面的字符串为`ABCDA`，其最长相同真前后缀为`A`，即`next[5] = 1`；
7. i = 6，前面的字符串为`ABCDAB`，其最长相同真前后缀为`AB`，即`next[6] = 2`；
8. i = 7，前面的字符串为`ABCDABD`，其最长相同真前后缀长度为 0，即`next[7] = 0`。

那么，为什么根据最长相同真前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如`i = 6`时不匹配，此时我们是知道其位置前的字符串为`ABCDAB`，仔细观察这个字符串，首尾都有一个`AB`，既然在`i = 6`处的 D 不匹配，我们为何不直接把`i = 2`处的 C 拿过来继续比较呢，因为都有一个`AB`啊，而这个`AB`就是`ABCDAB`的最长相同真前后缀，其长度 2 正好是跳转的下标位置。

有的读者可能存在疑问，若在`i = 5`时匹配失败，按照我讲解的思路，此时应该把`i = 1`处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是`B`，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要在这里纠结，跳过这个，下面你自然会恍然大悟。

思路如此简单，接下来就是代码实现了，如下：

```
/* P 为模式串，下标从 0 开始 */
void GetNext(string P, int next[])
{
    int p_len = P.size();
    int i = 0;   // P 的下标
    int j = -1;  
    next[0] = -1;

    while (i < p_len)
    {
        if (j == -1 || P[i] == P[j])
        {
            i++;
            j++;
            next[i] = j;
        }
        else
            j = next[j];
    }
}
```

一脸懵逼，是不是。。。上述代码就是用来求解模式串中每个位置的`next[]`值。

下面具体分析，我把代码分为两部分来讲：

**（1）：i 和 j 的作用是什么？**

i 和 j 就像是两个”指针“，一前一后，通过移动它们来找到最长的相同真前后缀。

**（2）：if...else...语句里做了什么？**

![img](https://segmentfault.com/img/remote/1460000021457888)

假设 i 和 j 的位置如上图，由`next[i] = j`得，也就是对于位置 i 来说，**区段 [0, i - 1] 的最长相同真前后缀分别是 [0, j - 1] 和 [i - j, i - 1]，即这两区段内容相同**。

按照算法流程，`if (P[i] == P[j])`，则`i++; j++; next[i] = j;`；若不等，则`j = next[j]`，见下图：

![img](https://segmentfault.com/img/remote/1460000021457886)

`next[j]`代表 [0, j - 1] 区段中最长相同真前后缀的长度。如图，用左侧两个椭圆来表示这个最长相同真前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以 else 语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到 [0, i - 1] 区段的相同真前后缀的长度。

细心的朋友会问 if 语句中`j == -1`存在的意义是何？第一，程序刚运行时，j 是被初始为 -1，直接进行`P[i] == P[j]`判断无疑会边界溢出；第二，else 语句中`j = next[j]`，j 是不断后退的，若 j 在后退中被赋值为 -1（也就是`j = next[0]`），在`P[i] == P[j]`判断也会边界溢出。综上两点，其意义就是为了特殊边界判断。

## 四：完整代码

```
#include <iostream>
#include <string>

using namespace std;

/* P 为模式串，下标从 0 开始 */
void GetNext(string P, int next[])
{
    int p_len = P.size();
    int i = 0;   // P 的下标
    int j = -1;  
    next[0] = -1;

    while (i < p_len)
    {
        if (j == -1 || P[i] == P[j])
        {
            i++;
            j++;
            next[i] = j;
        }
        else
            j = next[j];
    }
}

/* 在 S 中找到 P 第一次出现的位置 */
int KMP(string S, string P, int next[])
{
    GetNext(P, next);

    int i = 0;  // S 的下标
    int j = 0;  // P 的下标
    int s_len = S.size();
    int p_len = P.size();

    while (i < s_len && j < p_len) // 因为末尾 '\0' 的存在，所以不会越界
    {
        if (j == -1 || S[i] == P[j])  // P 的第一个字符不匹配或 S[i] == P[j]
        {
            i++;
            j++;
        }
        else
            j = next[j];  // 当前字符匹配失败，进行跳转
    }

    if (j == p_len)  // 匹配成功
        return i - j;
    
    return -1;
}

int main()
{
    int next[100] = { 0 };

    cout << KMP("bbc abcdab abcdabcdabde", "abcdabd", next) << endl; // 15
    
    return 0;
}
```

## 五：KMP优化

| i       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串     | A    | B    | C    | D    | A    | B    | D    | '\0' |
| next[i] | -1   | 0    | 0    | 0    | 0    | 1    | 2    | 0    |

以 3.2 的表格为例（已复制在上方），若在`i = 5`时匹配失败，按照 3.2 的代码，此时应该把`i = 1`处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是`B`，既然一样，拿过来比较不就是无用功了么？这我在 3.2 已经解释过，之所以会这样是因为 KMP 还未优化。那怎么改写就可以解决这个问题呢？很简单。

```
/* P 为模式串，下标从 0 开始 */
void GetNextval(string P, int nextval[])
{
    int p_len = P.size();
    int i = 0;   // P 的下标
    int j = -1;  
    nextval[0] = -1;

    while (i < p_len)
    {
        if (j == -1 || P[i] == P[j])
        {
            i++;
            j++;
          
            if (P[i] != P[j])
                nextval[i] = j;
            else
                nextval[i] = nextval[j];  // 既然相同就继续往前找真前缀
        }
        else
            j = nextval[j];
    }
}
```






https://www.cnblogs.com/xiaokang01/p/11593513.html

#                 [    KMP算法计算next值和nextVal值    ](https://www.cnblogs.com/xiaokang01/p/11593513.html)            

KMP算法：

给定一个主串S及一个模式串P，判断模式串是否为主串的子串；若是，返回匹配的第一个元素的位置（序号从1开始），否则返回0；

这里先不写算法，仅仅计算next和nextVal值

那么计算时只用到子串，也就是模式串

这里模式串为：**abaabcac**

第一步将模式串写上序号，我们这里从1开始（有的从0开始，建议充1开始）

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175611030-707750790.png)

 

 

 然后计算出maxL值，列出从第一个开始的子串，找出相等的前缀和后缀的个数

如果2>看不懂的话，看3>,

2>计算maxL值

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175746123-830043404.png)

 

所以maxL值

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180104311-1867715184.png)

 

 

 

 

 如果这个看不懂的话， 看下面的3>

3>， 如果2>看懂了这个就不用看了

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175900749-386717190.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175906041-2016474073.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175910819-484137433.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175915366-623813271.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175920247-1118557269.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926175924809-1714399548.png)

 

 

 依次类推

4>计算next值

 

 

接下来将maxL复制一行，去掉最后一个数，在开头添加一个-1，向右平移一个格，然后每个值在加1的到next值

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180324519-1730672870.png)

 

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180430013-1926403389.png)

 

 5>计算nextVal值，首先将第一个为0，然后看next和maxL是否相等（先计算不相等的）

当next和maxL不相等时，将next的值填入

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180626358-130620715.png)

 

 

当next和maxL相等时，填入对应序号为next值得nextVal值

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180707179-1314342266.png)

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180711293-1021048322.png)

 

 ![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180714808-1940324764.png)

 

 所以整个nextVal值为：

![img](https://img2018.cnblogs.com/blog/1396803/201909/1396803-20190926180740161-2123998353.png)

 







java实现代码：

```java

public class KMP {

    /**
     * 求出一个字符数组的next数组
     * @param t 字符数组
     * @return next数组
     */
    public static int[] getNextArray(char[] t) {
        int[] next = new int[t.length];
        next[0] = -1;
        next[1] = 0;
        int k;
        for (int j = 2; j < t.length; j++) {
            k=next[j-1];
            while (k!=-1) {
                if (t[j - 1] == t[k]) {
                    next[j] = k + 1;
                    break;
                }
                else {
                    k = next[k];
                }
                next[j] = 0;  //当k==-1而跳出循环时，next[j] = 0，否则next[j]会在break之前被赋值
            }
        }
        return next;
    }

    /**
     * 对主串s和模式串t进行KMP模式匹配
     * @param s 主串
     * @param t 模式串
     * @return 若匹配成功，返回t在s中的位置（第一个相同字符对应的位置），若匹配失败，返回-1
     */
    public static int kmpMatch(String s, String t){
        char[] s_arr = s.toCharArray();
        char[] t_arr = t.toCharArray();
        int[] next = getNextArray(t_arr);
        int i = 0, j = 0;
        while (i<s_arr.length && j<t_arr.length){
            if(j == -1 || s_arr[i]==t_arr[j]){
                i++;
                j++;
            }
            else
                j = next[j];
        }
        if(j == t_arr.length)
            return i-j;
        else
            return -1;
    }

    public static void main(String[] args) {
        System.out.println(kmpMatch("abcabaabaabcacb", "abaabcac"));
    }

}
```

